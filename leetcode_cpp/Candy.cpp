/*
time   :  2015-5-29
author :  ht
comment:  分糖果问题  需要用到贪心算法
*/
#include<iostream>
#include<cmath>
#include<string>
#include<queue>
#include<vector>
#include<map>
using namespace std;

class Solution {
public:
	int candy(vector<int>& ratings) {
		return traverse(ratings);
	}
	int traverse(vector<int> ratings)
	{
		/*
		 *  需要扫描三遍数据
		 *  第一遍，确定 ratings分布的谷底，题目的要求是与自己相邻的ratings，
		 *  只有比自己大的时候分配的糖果多，所以说相等的时候也没有用 所以遍历到i的时候 ratings[i]<=ratings[i+1] &&ratings[i]<=ratings[i-1]
		 *  两边的时候特殊处理一下
		 *   
		 *  第二遍的时候从peak开始找上升的部分，这一部分正向扫描（我的代码写的有些冗余，以后再看的时候再修改吧）
		 *  记住每次扫描的时候不能改变peak位置的值，一定要限定，因为在元素相等的时候会发生这种坑爹的情况，例如  1 2 2 或者 2 2 1
		 *  这一个部分把每个peak之间上升的部分给解决了，每上一个台阶 +1 ，当遇到前后两个元素相等的时候count 要置为1，然后重新上台阶
		 *  当遇到visited过的数据之后，取当前值和count中较大的，接着break，不能往后走了
		 *  
		 *  接着逆向扫描第三遍
		 *  过程和第二遍是一样的，只不过看的方向是从后往前，上升了
		 *   
		 *  复杂度是线性的，还有一些很简洁的算法，目前暂时不写了
		 */
		int len = ratings.size();
		vector<int> height(len,0);
		vector<bool>visited(len,false);
		vector<bool>peak(len, false);
		if (ratings[0] <= ratings[1])
		{
			height[0] = 1; 
			visited[0] = true;
			peak[0] = true;
		}
			
		if (ratings[len - 1] <= ratings[len - 2])
		{
			height[len-1] = 1;
			visited[len - 1] = true;
			peak[len-1] = true;
		}
			
		int i;
		for (i = 1; i < len - 1; i++)
		{ 
			if (ratings[i] <= ratings[i - 1] && ratings[i] <= ratings[i + 1])
			{
				height[i] = 1;
				visited[i] = true;
				peak[i] = true;
			}
		}
		//正向扫一遍
		i = 0;
		int count = 0;
		while (i < len)
		{
			while (i<len && height[i] != 1)
				i++;
			count = 1;
			while ((i + 1)<len && ratings[i + 1] >= ratings[i]&&!peak[i+1])
			{
				//peak就是第一次画好的边界，不能越过去
				if (ratings[i] == ratings[i + 1])
				{
					if (visited[i + 1])
					{
						//如果以前访问过，这里求一个较大的直接退出
						height[i + 1] = myMax(count,height[i+1]);
						break;
					}
					else
					{
						count = 1;
						//没有访问过，台阶是平的，count重置
						height[i + 1] = count;
					}
						
				}	
				else
				{
					count++;
					//上升部分  count不断上台阶
					if (visited[i + 1])
					{
						height[i + 1] = myMax(count, height[i + 1]);
						break;
					}
					else
						height[i + 1] = count;
				}
				visited[i + 1] = true;
				i++;
			}
			i++;
		}

		//反向扫描一遍
		i = len - 1;
		while (i >=0)
		{
			while (i>=0 && height[i] != 1)
				i--;
			count = 1;
			while ((i - 1) >= 0 && ratings[i - 1] >= ratings[i] && !peak[i - 1])
			{
				//peak就是第一次画好的边界，不能越过去
				if (ratings[i] == ratings[i - 1])
				{
					if (visited[i - 1])
					{
						height[i - 1] = myMax(count, height[i - 1]);
						break;
					}
					else
					{
						//没有访问过，台阶是平的，count重置
						count = 1;
						height[i - 1] = count;
					}
				}
				else
				{
					count++;
					//逆向上升部分  count不断上台阶
					if (visited[i - 1])
					{
						height[i - 1] = myMax(count, height[i - 1]);
						break;
					}
					else
						height[i - 1] = count;
				}
				visited[i - 1] = true;
				i--;
			}
			i--;
		}
		int sum = 0;
		for (i = 0; i < len; i++)
			sum += height[i];
		return sum;

	}
	int myMin(int a,int b)
	{
		return a > b ? b : a;
	}
	int myMax(int a, int b)
	{
		return a > b ? a : b;
	}
};

int main()
{
	//vector<int> ratings = {4,3,5,8,9,7};
	vector<int> ratings = { 370, 28, 37, 15, 379, 458, 342, 346, 328, 257, 81, 400, 426, 461, 349, 362, 315, 410, 427, 458, 264, 322, 326, 350, 369, 383, 184, 343, 402, 274, 184, 124, 154, 73, 491, 33, 31, 333, 379, 212, 91, 313, 112, 369, 274, 461, 83, 441, 223, 362, 399, 339, 185, 77, 189, 406, 312, 373, 249, 66, 147, 433, 191, 153, 358, 182, 187, 242, 368, 418, 454, 311, 231, 418, 180, 358, 379, 115, 151, 454, 478, 403, 293, 163, 480, 482, 69, 145, 207, 318, 63, 207, 103, 254, 360, 313, 289, 399, 55, 9, 318, 361, 320, 401, 279, 352, 111, 10, 319, 263, 464, 297, 18, 109, 460, 350, 91, 381, 495, 151, 51, 59, 358, 6, 165, 218, 320, 306, 118, 375, 315, 288, 89, 487, 41, 368, 191, 5, 379, 11, 120, 195, 308, 138, 305, 121, 488, 248, 2, 336, 399, 406, 395, 257, 412, 412, 328, 232, 71, 446, 460, 238, 86, 49, 226, 127, 417, 269, 132, 148, 280, 104, 344, 441, 242, 1, 414, 231, 101, 416, 419, 1, 174, 314, 110, 87, 78, 438, 319, 149, 236, 279, 388, 322, 328, 466, 302, 98, 235, 286, 246, 368, 391, 442, 161, 133, 295, 75, 216, 397, 343, 135, 250, 18, 301, 360, 105, 232, 299, 424, 381, 35, 56, 121, 210, 384, 439, 12, 482, 175, 298, 81, 395, 41, 23, 408, 175, 171, 483, 243, 68, 178, 231, 318, 48, 32, 178, 153, 116, 329, 430, 498, 217, 338, 471, 279, 222, 411, 291, 57, 438, 441, 490, 185, 483, 365, 93, 10, 36, 428, 105, 104, 106, 336, 274, 155, 221, 305, 160, 337, 134, 442, 335, 203, 280, 159, 482, 355, 70, 125, 412, 360, 67, 254, 45, 402, 119, 138, 412, 156, 66, 17, 112, 24, 206, 387, 179, 427, 192, 192, 264, 178, 134, 452, 382, 415, 111, 216, 270, 33, 342, 34, 393, 261, 288, 290, 163, 407, 428, 427, 63, 346, 444, 176, 370, 2, 415, 402, 429, 107, 94, 194, 285, 80, 146, 19, 495, 109, 236, 117, 494, 78, 151, 387, 191, 439, 29, 354, 199, 457, 281, 114, 155, 77, 290, 25, 80, 57, 279, 361, 164, 225, 55, 302, 306, 53, 321, 153, 14, 57, 271, 8, 487, 422, 247, 178, 214, 276, 384, 413, 233, 17, 27, 240, 95, 170, 118, 27, 227, 397, 388, 244, 475, 296, 46, 281, 201, 367, 434, 216, 277, 57, 224, 264, 332, 472, 295, 398, 248, 179, 311, 334, 197, 190, 74, 144, 212, 192, 23, 292, 442, 263, 388, 417, 411, 434, 50, 113, 153, 336, 329, 430, 394, 53, 47, 226, 377, 194, 124, 126, 225, 287, 312, 274, 329, 238, 418, 394, 283, 293, 186, 225, 409, 426, 494, 320, 360, 44, 433, 365, 380, 262, 148, 126, 316, 47, 204, 45, 241, 180, 23, 466, 467, 335, 241, 149, 426, 11, 43, 209, 157, 81, 286, 66, 7, 280, 386, 219, 176, 320 };
	Solution mine;
	int result = 0;
	result = mine.candy(ratings);
	cout << result << endl;
	return 0;
}